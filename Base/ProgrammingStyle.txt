Programming Style Guidelines for Maxine Project Software
---------------------------------------------------------

Write code as if there were only one author.

Do not mix styles!

If you want to change our common style, that is completely acceptable.
Improvements are welcome.
Then let's talk about it, let's decide together 
and then make the appropriate change consistently in all source code altogether.

If that is too much of a burden, though,
then you must submit to our existing style and stick to it!

Most rules are expressed in our CheckStyle Eclipse plugin configuration.
See http://eclipse-cs.sourceforge.net/

If using Eclipse, you should also import the code style format profile from
Base/.settings/JavaSourceCodeFormatting.xml. This is under Window|Preferences|Java|Code Style|Formatter|Import...

We also use FindBugs from time to time,
but there is no rule to eliminate all of its findings,
which are replete with false positives.
See http://findbugs.sourceforge.net/


Code Formatting
---------------

Indentation is 4 spaces.

TAB characters are ABSOLUTELY BANNED.

Opening curly braces appear at the end of the first line of the respective construct, not on the second line.
Closing curly braces are indented matching the first character of the first line of the respective construct.
See the correct if-statement below as an example.

"if"-statements ALWAYS use curly braces.
So do else-clauses etc.
DO NOT ever write this:

    if (condition) statement;
    
or this

    if (condition)
        statement;
        
Instead ALWAYS write this:

    if (condition) {
        statement;
    }

The "else" goes on the same line as the closing brace of the "if":

    if (condition) {
        ...
    } else {
        ...
    }

When using Eclipse, make sure you have the IDE's code formatting rules 
defined by importing "MaxineBase/eclipse/JavaSourceCodeFormattting.xml".
(When you import an Eclipse project from us, this will automatically be the case.)
Tip: you can find out more about our formatting rules
by browsing the corresponding Eclipse dialog boxes.

There is a white space before and after every arithmetic operator ('+', '|', '<<', etc.), 
comparison operator ('<', '!=', etc.), assignment sign ('='), etc.

Catch variables are named after the catch type.
Example:

    try {
        ...
    } catch (MySortOfException mySortOfException) {
        ...
    }


Naming conventions
------------------

Interfaces and classes start with an upper case letter, e.g. MyClass, YourInterface.

Methods start with a lower case letter, e.g. foo, fooBar, yourMethodIsNotCalledFooBar.

Private fields, protected fields, and non-final public fields start with a lower-case letter. 
(e.g. myField, offset)

Public final fields are all upper case (with "_" word delimiters), e.g. ALL_UPPER_CASE.

There are certain exceptions, which always have to do with interactions with pre-existing
structures outside our software (e.g. JNI, assembler syntax).

In general, we never use non-private fields unless we "absolutely have to".


"..._Type" - type parameter, same as classes and interfaces, except for the suffix, 
             e.g. Element_Type, MethodActor_Type.

"numberOf..." - the number of given things as in counting them

"size" - measure of bytes, referring to a sequential span
"length" - measure of units of whatever (e.g. integers, floats, boats, yachts), referring to a sequential span

"width" - measure of bits in a machine word

"offset" - measure of bytes, relative to a position
"index" - measure of units of whatever, referring to a position
"scale" - unit size in bytes

Concerning pointer/reference/accessor operations:

"read", "write" - access by byte offset
"get", "set"    - access by index with scale (and displacement)

"load"  - generalization of "read" and "get"
"store" - generalization of "write" and "set"

"address" - a point in a linear address space with a fixed start address, unsigned
"offset" - the signed distance between two addresses
"position" - the unsigned offset from the beginning of a linear address space without a fixed start address or lacking such notion (e.g. a file)

The term "address" could be ambiguous when used to describe points within an instruction stream. It might mean
the absolute address of the instruction in a global address space, the offset from the start of the
instruction stream for a given method or the offset between two points in an instruction stream. For
this reason, we use the term "position" for a point relative to the beginning of the instruction
stream. To describe the (directed) distance between two points (which are not necessarily correlated with the first
byte of an instruction) in the instruction stream, we use the term "offset". We prefix both of these
terms with a name describing the type of instruction stream (e.g. "bytecode", "target code", etc).
Based on this, we have:
   Bytecode position: A point in a bytecode array. A bytecode position is always positive.
   Bytecode offset: An offset from one point in a bytecode array to another point in the
       bytecode array. A bytecode offset is negative if the second point precedes the first
       point in the bytecode array.
   Target code position: A position in target code (i.e. machine code). A target code position
       is always positive.
   Target code offset: An offset from one point in a target code array to another point in
      the target code array. A target code offset is negative if the second point precedes
      the first point in the target code array.


Construction/factory method naming conventions
----------------------------------------------

"create" X - allocate an X data structure (always)
"make" X   - get the data structure X if it exists, create (and possibly cache) it otherwise
"get" X    - get/obtain/compute the data structure X if it exists, return null otherwise; may involve work


Enum classes
------------

Note that each enum type has a static 'values()' method that returns an array containing all
of the values of the enum type in the order they are declared. Unfortunately, there is no
support for immutable arrays in Java and so a new array is returned each time the 'values()'
method is called. This imposes unecessary overhead if all you want is to retrieve an enum constant
based on its ordinal, iterate over all the constants or want to know how many constants there are.
In theory, an optimizing compiler should be able to remove most of this overhead but it has been our
experience so far that this is not the case, even for the HotSpot server compiler.

As such, we always declare an extra field named 'VALUES' in enum classes that exposes an immutable, iterable and
indexable view of the enum constants. For example:

    public enum Symbol {
        ONE,
        TWO,
        THREE,
        FOUR;
        
        public static final IndexedSequence<Symbol> VALUES = new ArraySequence<Symbol>(values());
    }

The use of 'final'
------------------

Parameters, variables in for-loops and exception variables
should only be declared final if required due to access by an anonymous class.

CheckStyle has a rule that forbids assignments to parameters.
We use that rule. This effectively makes all parameters final without requiring us to declare it.


Type Casts
----------

A white space is required after a type cast.

Using @SuppressWarnings("unchecked") is strictly prohibited,
except for implementing 'StaticLoophole.cast()'.
The annotation usually applies to too wide a scope of source code,
obfuscating what operations exactly are potentially unsafe.
Use StaticLoophole.cast() to achieve the same effect at a precisely defined code location!
(@SuppressWarnings("unchecked") may be used to implement StaticLoophole, but nothing else.)


Array Declarations
------------------

No space between the element type and the brackets.
Example: 
    
    byte[] array = new byte[3];
    
No space between the angular brackets and the brace of an aggregate.
Example:

    Color[] array = new Color{RED, GREEN, BLUE};


Commented-out code
------------------

Is not allowed. Everybody is entitled to zap commented-out code at first sight without any regard at all what it is.
If it's really valuable, keep it compiling along, so that it survives refactoring.
If it's not that valuable, the version control system will still have a copy somewhere.

If you are refactoring and some code needs to stay around in comments for a while,
that's fine, but do NOT propagate such leftovers to the group.
Keep those commented-out pieces to yourself and clean them up first,
only then propagate (SCCS putback / CVS commit).


Javadoc
-------

Make sure all program elements use javadoc comment delimiters. That is:

/**
 * Javadoc comment that conforms with the guidelines at http://java.sun.com/j2se/javadoc/writingdoccomments/
 */

Modern IDEs usually provide support for auto-formatting of Javadoc comments. It's recommended to
configure the settings for the auto-formatting to follow these guidelines. This ensures a visual
consistency to the formatted comments.

Important points to note from the guidelines mentioned above as well as additions include:

o Use a Javadoc tag instead of a HTML construct if possible. For example,
  use {@code ...} instead of <code>...</code>.
  
o Use 3rd person (descriptive) not 2nd person (prescriptive). For example:
    Gets the label.  (preferred)
    Get the label. 	 (avoid) 

o Use "this" instead of "the" when referring to an object related to the current class. For example:
    Gets the toolkit for this component.   (preferred)
    Gets the toolkit for the component.    (avoid)

