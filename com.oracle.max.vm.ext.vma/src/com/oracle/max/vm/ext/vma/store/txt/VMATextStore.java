/*
 * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.oracle.max.vm.ext.vma.store.txt;

import com.oracle.max.vm.ext.vma.*;

/**
 * An interface that is derived from {@link VMAdviceHandler} but is suitable for persistent textual storage. I.e., object
 * instances are represented by unique identifiers, class instances by their name and classloader instance id, method by
 * name, etc. This class is, therefore, completely VM independent.
 *
 * Time is explicitly represented by the first argument to the advice store methods.
 *
 * Much of this class is auto-generated by {@link VMATextStoreGenerator}.
 *
 * An implementation must be thread-safe either by design or by appropriate synchronization.
 *
 * The interface provides explicit support for per-thread stores through the {@code threadBatched}
 * and {@code perThread} arguments to {@link #initializeStore}. If both of these values are {@code false}
 * then the assumption is that calls from multiple threads are interleaved. If {@code threadBatched}
 * is {@code true} then calls are batched from the same thread and each batch must be preceded by
 * a call to {@link #threadSwitch}. If {@code perThread} is {@code true}, which implies that {@code threadBatched}
 * is {@code true}, then the store implementation is expected to support per-thread stores. The caller
 * must announce new threads via the {@link #newThread} method and subsequently use the returned {@VMATextStore}
 * instance when storing records for that thread.
 *
 */
public abstract class VMATextStore {

    /**
     * Initialize the store subsystem.
     * @param threadBatched {@code true} thread records are batched together and not interleaved
     * @param perThread a request for per thread output store if possible
     * @return {@code true} iff the initialization was successful.
     */
    public abstract boolean initializeStore(boolean threadBatched, boolean perThread);

    /**
     * Finalize the store, e.g. flush trace.
     */
    public abstract void finalizeStore();

    /**
     * Log the removal on an object from the VM (i.e. object death).
     * @param id
     */
    public abstract void removal(long id);

    /**
     * Record an object that was not seen by the adviseNew methods but was used in an operation.
     *
     * @param time
     * @param threadName irrelevant but included for consistency with other methods
     * @param objId
     * @param className
     * @param clId
     */
    public abstract void unseenObject(long time, String threadName, long objId, String className, long clId);

    /**
     * In per-thread mode must be called notify the start of a new thread, typically
     * from {@code adviseBeforeThreadStarting}, but certainly before any {@code adviseXXX} methods
     * of this called are called.
     * For per-thread stores may return a per-thread specific store that should be
     * used instead of {@code this}.
     */
    public abstract VMATextStore newThread(String threadName);

    /**
     * Must be called in {@link #threadBatched} mode to indicate records now for given thread.
     */
    public abstract void threadSwitch(long time, String threadName);

// START GENERATED CODE
// EDIT AND RUN VMATextStoreGenerator.main() TO MODIFY

    public abstract void adviseBeforeGC(long time, String threadName);

    public abstract void adviseAfterGC(long time, String threadName);

    public abstract void adviseBeforeThreadStarting(long time, String threadName);

    public abstract void adviseBeforeThreadTerminating(long time, String threadName);

    public abstract void adviseBeforeReturnByThrow(long time, String threadName, long objId, int poppedFrames);

    public abstract void adviseBeforeConstLoad(long time, String threadName, long value);

    public abstract void adviseBeforeConstLoadObject(long time, String threadName, long value);

    public abstract void adviseBeforeConstLoad(long time, String threadName, float value);

    public abstract void adviseBeforeConstLoad(long time, String threadName, double value);

    public abstract void adviseBeforeLoad(long time, String threadName, int arg1);

    public abstract void adviseBeforeArrayLoad(long time, String threadName, long objId, int index);

    public abstract void adviseBeforeStore(long time, String threadName, int index, long value);

    public abstract void adviseBeforeStore(long time, String threadName, int index, float value);

    public abstract void adviseBeforeStore(long time, String threadName, int index, double value);

    public abstract void adviseBeforeStoreObject(long time, String threadName, int index, long value);

    public abstract void adviseBeforeArrayStore(long time, String threadName, long objId, int index, float value);

    public abstract void adviseBeforeArrayStore(long time, String threadName, long objId, int index, long value);

    public abstract void adviseBeforeArrayStore(long time, String threadName, long objId, int index, double value);

    public abstract void adviseBeforeArrayStoreObject(long time, String threadName, long objId, int index, long value);

    public abstract void adviseBeforeStackAdjust(long time, String threadName, int arg1);

    public abstract void adviseBeforeOperation(long time, String threadName, int arg1, long arg2, long arg3);

    public abstract void adviseBeforeOperation(long time, String threadName, int arg1, float arg2, float arg3);

    public abstract void adviseBeforeOperation(long time, String threadName, int arg1, double arg2, double arg3);

    public abstract void adviseBeforeConversion(long time, String threadName, int arg1, float arg2);

    public abstract void adviseBeforeConversion(long time, String threadName, int arg1, long arg2);

    public abstract void adviseBeforeConversion(long time, String threadName, int arg1, double arg2);

    public abstract void adviseBeforeIf(long time, String threadName, int opcode, int op1, int op2);

    public abstract void adviseBeforeIfObject(long time, String threadName, int opcode, long objId1, long objId2);

    public abstract void adviseBeforeBytecode(long time, String threadName, int arg1);

    public abstract void adviseBeforeReturn(long time, String threadName);

    public abstract void adviseBeforeReturn(long time, String threadName, long value);

    public abstract void adviseBeforeReturn(long time, String threadName, float value);

    public abstract void adviseBeforeReturn(long time, String threadName, double value);

    public abstract void adviseBeforeReturnObject(long time, String threadName, long value);

    public abstract void adviseBeforeGetStatic(long time, String threadName, String className, long clId, String fieldName);

    public abstract void adviseBeforePutStaticObject(long time, String threadName, String className, long clId, String fieldName, long value);

    public abstract void adviseBeforePutStatic(long time, String threadName, String className, long clId, String fieldName, float value);

    public abstract void adviseBeforePutStatic(long time, String threadName, String className, long clId, String fieldName, double value);

    public abstract void adviseBeforePutStatic(long time, String threadName, String className, long clId, String fieldName, long value);

    public abstract void adviseBeforeGetField(long time, String threadName, long objId, String className, long clId, String fieldName);

    public abstract void adviseBeforePutFieldObject(long time, String threadName, long objId, String className, long clId, String fieldName, long value);

    public abstract void adviseBeforePutField(long time, String threadName, long objId, String className, long clId, String fieldName, float value);

    public abstract void adviseBeforePutField(long time, String threadName, long objId, String className, long clId, String fieldName, double value);

    public abstract void adviseBeforePutField(long time, String threadName, long objId, String className, long clId, String fieldName, long value);

    public abstract void adviseBeforeInvokeVirtual(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseBeforeInvokeSpecial(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseBeforeInvokeStatic(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseBeforeInvokeInterface(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseBeforeArrayLength(long time, String threadName, long objId, int length);

    public abstract void adviseBeforeThrow(long time, String threadName, long objId);

    public abstract void adviseBeforeCheckCast(long time, String threadName, long objId, String className, long clId);

    public abstract void adviseBeforeInstanceOf(long time, String threadName, long objId, String className, long clId);

    public abstract void adviseBeforeMonitorEnter(long time, String threadName, long objId);

    public abstract void adviseBeforeMonitorExit(long time, String threadName, long objId);

    public abstract void adviseAfterInvokeVirtual(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseAfterInvokeSpecial(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseAfterInvokeStatic(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseAfterInvokeInterface(long time, String threadName, long objId, String className, long clId, String methodName);

    public abstract void adviseAfterNew(long time, String threadName, long objId, String className, long clId);

    public abstract void adviseAfterNewArray(long time, String threadName, long objId, String className, long clId, int length);

    public abstract void adviseAfterMultiNewArray(long time, String threadName, long objId, String className, long clId, int length);

    public abstract void adviseAfterMethodEntry(long time, String threadName, long objId, String className, long clId, String methodName);

// END GENERATED CODE
}
