/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.max.vm.t1x;

import static com.sun.max.platform.Platform.*;
import static com.sun.max.vm.MaxineVM.*;
import static com.sun.max.vm.compiler.target.Stub.Type.*;
import static com.sun.max.vm.stack.JVMSFrameLayout.*;
import static com.sun.max.vm.stack.StackReferenceMapPreparer.*;
import static com.sun.max.vm.t1x.T1XCompilation.*;

import java.util.*;

import com.sun.cri.bytecode.*;
import com.sun.cri.ci.*;
import com.sun.cri.ri.*;
import com.sun.max.annotate.*;
import com.sun.max.atomic.*;
import com.sun.max.io.*;
import com.sun.max.unsafe.*;
import com.sun.max.vm.*;
import com.sun.max.vm.actor.holder.*;
import com.sun.max.vm.actor.member.*;
import com.sun.max.vm.bytecode.*;
import com.sun.max.vm.bytecode.refmaps.*;
import com.sun.max.vm.classfile.*;
import com.sun.max.vm.classfile.constant.*;
import com.sun.max.vm.code.*;
import com.sun.max.vm.collect.*;
import com.sun.max.vm.compiler.*;
import com.sun.max.vm.compiler.deopt.Deoptimization.CallerContinuation;
import com.sun.max.vm.compiler.deopt.Deoptimization.Continuation;
import com.sun.max.vm.compiler.deopt.Deoptimization.Info;
import com.sun.max.vm.compiler.target.*;
import com.sun.max.vm.compiler.target.amd64.*;
import com.sun.max.vm.object.*;
import com.sun.max.vm.profile.*;
import com.sun.max.vm.reference.*;
import com.sun.max.vm.runtime.*;
import com.sun.max.vm.stack.*;
import com.sun.max.vm.stack.StackFrameWalker.Cursor;
import com.sun.max.vm.stack.amd64.*;
import com.sun.max.vm.t1x.T1XTemplate.StopsBuilder;
import com.sun.max.vm.thread.*;
import com.sun.max.vm.type.*;

/**
 * A target method generated by T1X.
 */
public final class T1XTargetMethod extends TargetMethod {

    static final int SYNC_METHOD_CATCH_TYPE_CPI = -1;

    /**
     * The number of slots to be reserved in each T1X frame for template spill slots.
     * This is the max number of slots used by any template and is computed when the templates are
     * {@linkplain T1X#createTemplates(Class, T1X, boolean, com.sun.max.vm.t1x.T1X.Templates) created}.
     */
    static int templateSlots;

    /**
     * The frame and register reference maps for this target method.
     *
     * The format of this byte array is described by the following pseudo C declaration:
     * <p>
     *
     * <pre>
     * referenceMaps {
     *     {
     *         u1 frameMap[frameRefMapSize];
     *         u1 regMap[regRefMapSize];
     *     } directCallMaps[numberOfDirectCalls]
     *     {
     *         u1 frameMap[frameRefMapSize];
     *         u1 regMap[regRefMapSize];
     *     } indirectCallMaps[numberOfIndirectCalls]
     *     {
     *         u1 frameMap[frameRefMapSize];
     *         u1 regMap[regRefMapSize];
     *     } safepointMaps[numberOfSafepoints]
     * }
     * </pre>
     */
    private final byte[] refMaps;

    /**
     * Offset from the frame pointer (e.g. %rbp on AMD64) to the bottom of the frame.
     * This is the address to which the frame reference maps are relative.
     */
    public final int frameRefMapOffset;

    public final int frameRefMapSize;

    @INSPECTED(deepCopied = false)
    private final AtomicReference refMapEditor = new AtomicReference();

    /**
     * The frame layout.
     */
    public final JVMSFrameLayout frame;

    /**
     * The bytecode from which this target method was compiled. This will differ from
     * the bytecode hanging off of {@link #classMethodActor} in the case where it was rewritten.
     */
    public final CodeAttribute codeAttribute;

    /**
     * A bit map denoting which {@linkplain #directCallees() direct calls} in this target method correspond to calls
     * into the runtime derived from the constituent templates. These calls are linked using {@link CallEntryPoint#OPTIMIZED_ENTRY_POINT}.
     * All other direct calls are linked using {@link CallEntryPoint#BASELINE_ENTRY_POINT}.
     */
    public final CiBitMap isDirectCallToRuntime;

    /**
     * An array that encodes a mapping from BCIs to target code positions. A non-zero value
     * {@code val} at index {@code i} in the array encodes that there is a bytecode instruction whose opcode is at index
     * {@code i} in the bytecode array and whose target code position is {@code val}. Unless {@code i} is equal to the
     * length of the bytecode array in which case {@code val} denotes the target code position one byte past the
     * last target code byte emitted for the last bytecode instruction.
     */
    public final int[] bciToPos;

    public final CiExceptionHandler[] handlers;

    /**
     * The profile for this method - if there is one (otherwise, null).
     */
    public final MethodProfile profile;

    public T1XTargetMethod(T1XCompilation comp, boolean install) {
        super(comp.method, CallEntryPoint.BASELINE_ENTRY_POINT);

        codeAttribute = comp.codeAttribute;
        bciToPos = comp.bciToPos;
        frame = comp.frame;
        frameRefMapOffset = frame.frameReferenceMapOffset();
        setFrameSize(frame.frameSize());
        frameRefMapSize = frame.frameReferenceMapSize();

        StopsBuilder stops = comp.stops;
        int firstTemplateSlot = frame.numberOfNonParameterSlots() + frame.numberOfOperandStackSlots();
        int firstTemplateSlotIndexInFrameReferenceMap = firstTemplateSlot * JVMSFrameLayout.STACK_SLOTS_PER_JVMS_SLOT;
        stops.pack(frameRefMapSize, regRefMapSize(), firstTemplateSlotIndexInFrameReferenceMap, comp.adapter);
        setStopPositions(stops.stopPositions, stops.directCallees, stops.indirectCalls.size, stops.safepoints.size);
        refMaps = stops.refMaps;
        isDirectCallToRuntime = stops.isDirectCallToRuntime;
        handlers = initHandlers(comp);

        if (comp.methodProfileBuilder != null) {
            comp.methodProfileBuilder.finish(this);
            profile = comp.methodProfileBuilder.methodProfileObject();
        } else {
            profile = null;
        }

        // Allocate and set the code and data buffer
        final TargetBundleLayout targetBundleLayout = new TargetBundleLayout(0, comp.referenceLiterals.size(), comp.buf.position());
        if (install) {
            Code.allocate(targetBundleLayout, this);
        } else {
            Code.allocateInHeap(targetBundleLayout, this);
        }

        // Copy code
        comp.buf.copyInto(code, 0, code.length);

        // Copy reference literals
        if (referenceLiterals != null) {
            // Must not cause checkcast here, since some reference literals may be static tuples.
            int j = 0;
            for (int i = comp.referenceLiterals.size() - 1; i >= 0; i--) {
                Object literal = comp.referenceLiterals.get(i);
                ArrayAccess.setObject(referenceLiterals, j++, literal);
            }
        }

        if (stopPositions != null) {
            final T1XReferenceMapEditor referenceMapEditor = new T1XReferenceMapEditor(this, comp.numberOfBlocks, comp.blockBCIs, stops.bytecodeStopsIterator, frame);
            this.refMapEditor.set(referenceMapEditor);
            final ReferenceMapInterpreter interpreter = ReferenceMapInterpreter.from(referenceMapEditor.blockFrames());
            if (interpreter.performsAllocation() || T1XOptions.EagerRefMaps || T1XOptions.PrintCFGToFile) {
                if (isHosted() && T1XOptions.EagerRefMaps) {
                    StackReferenceMapPreparer.TraceSRS = true;
                }
                finalizeReferenceMaps();
            }
        }

        if (!MaxineVM.isHosted()) {
            if (install) {
                linkDirectCalls();
            } else {
                // the displacement between a call site in the heap and a code cache location may not fit in the offset operand of a call
            }
        }
    }

    @Override
    public MethodProfile profile() {
        return profile;
    }

    @Override
    public int[] bciToPosMap() {
        return bciToPos;
    }

    /**
     * Initializes the exception handlers for this method, adding an extra one if necessary for
     * a synchronized method. This synthesized handler covers the method code from the
     * instruction immediately after the lock on the receiver/class was acquired to the
     * instruction just after the lock is released. This mimics the exception handler
     * range generated by Java source compilers for synchronized blocks. The synthesized
     * handler is in terms of machine code positions, not BCIs and is distinguished by
     * its {@link CiExceptionHandler#catchTypeCPI} being {@link #SYNC_METHOD_CATCH_TYPE_CPI}.
     */
    private CiExceptionHandler[] initHandlers(T1XCompilation comp) {
        if (comp.method.isSynchronized()) {
            CiExceptionHandler[] handlers = comp.handlers;
            CiExceptionHandler[] newHandlers = Arrays.copyOf(handlers, handlers.length + 1);
            CiExceptionHandler syncMethodHandler =
                new CiExceptionHandler(comp.syncMethodStartPos,
                                       comp.syncMethodEndPos,
                                       comp.syncMethodHandlerPos,
                                       SYNC_METHOD_CATCH_TYPE_CPI,
                                       null);
            newHandlers[handlers.length] = syncMethodHandler;

            // Update the reference maps to cover the local variable holding the copy of the receiver
            if (comp.synchronizedReceiver != -1) {
                for (int stopIndex = 0; stopIndex < stopPositions.length; stopIndex++) {
                    int pos = StopPositions.get(stopPositions, stopIndex);
                    if (pos >= comp.syncMethodStartPos && pos < comp.syncMethodEndPos) {
                        final int offset = stopIndex * refMapSize();
                        final int refMapBit = frame.localVariableReferenceMapIndex(comp.synchronizedReceiver);
                        ByteArrayBitMap.set(refMaps, offset, frameRefMapSize, refMapBit);
                    }
                }
            }
            return newHandlers;
        }
        return comp.handlers;
    }

    int sizeOfNonParameterLocals() {
        return JVMSFrameLayout.JVMS_SLOT_SIZE * frame.numberOfNonParameterSlots();
    }

    @HOSTED_ONLY
    @Override
    public void gatherCalls(Set<MethodActor> directCalls, Set<MethodActor> virtualCalls, Set<MethodActor> interfaceCalls, Set<MethodActor> inlinedMethods) {
        final BytecodeVisitor bytecodeVisitor = new InvokedMethodRecorder(classMethodActor, directCalls, virtualCalls, interfaceCalls);
        final BytecodeScanner bytecodeScanner = new BytecodeScanner(bytecodeVisitor);
        bytecodeScanner.scan(new BytecodeBlock(codeAttribute.code()));
    }

    @Override
    public boolean isPatchableCallSite(Address callSite) {
        return AMD64TargetMethodUtil.isPatchableCallSite(callSite);
    }

    @Override
    public Address fixupCallSite(int callOffset, Address callEntryPoint) {
        return AMD64TargetMethodUtil.fixupCall32Site(this, callOffset, callEntryPoint);
    }

    public byte[] referenceMaps() {
        return refMaps;
    }

    /**
     * Gets the size (in bytes) of a bit map covering all the registers that may store references.
     * The bit position of a register in the bit map is the register's {@linkplain CiRegister#encoding encoding}.
     */
    @FOLD
    static int regRefMapSize() {
        return ByteArrayBitMap.computeBitMapSize(target().arch.registerReferenceMapBitCount);
    }

    @Override
    public Address patchCallSite(int callOffset, Address callEntryPoint) {
        return AMD64TargetMethodUtil.mtSafePatchCallDisplacement(this, codeStart().plus(callOffset), callEntryPoint.asAddress());
    }

    @Override
    public void traceDebugInfo(IndentWriter writer) {
    }

    @Override
    protected CallEntryPoint callEntryPointForDirectCall(int directCallIndex) {
        if (isDirectCallToRuntime != null && isDirectCallToRuntime.get(directCallIndex)) {
            return CallEntryPoint.OPTIMIZED_ENTRY_POINT;
        }
        return super.callEntryPointForDirectCall(directCallIndex);
    }

    @HOSTED_ONLY
    @Override
    protected boolean isDirectCalleeInPrologue(int directCalleeIndex) {
        return stopPosition(directCalleeIndex) < posForBci(0);
    }

    public int posForBci(int bci) {
        return bciToPos[bci];
    }

    @Override
    public CiDebugInfo debugInfoAt(int stopIndex, FrameAccess fa) {
        CiBitMap frameRefMap = new CiBitMap(referenceMaps(), stopIndex * refMapSize(), frameRefMapSize);
        CiBitMap regRefMap = new CiBitMap(referenceMaps(), (stopIndex * refMapSize()) + frameRefMapSize, regRefMapSize());
        int bci = bciForPos(stopPosition(stopIndex));
        CiFrame debugFrame = frame.asFrame(classMethodActor, bci, frameRefMap);
        return new CiDebugInfo(debugFrame, regRefMap, frameRefMap);
    }

    @Override
    public int forEachCodePos(CodePosClosure cpc, Pointer ip, boolean ipIsReturnAddress) {
        if (ipIsReturnAddress && platform().isa.offsetToReturnPC == 0) {
            ip = ip.minus(1);
        }
        int bci = bciFor(ip.asPointer());
        if (bci >= 0) {
            cpc.doCodePos(classMethodActor, bci);
            return 1;
        }
        return 0;
    }

    /**
     * Gets the BCI for a machine code instruction address.
     *
     * @param ip an instruction pointer that may denote an instruction in this target method
     * @return the start position of the bytecode instruction that is implemented at the instruction pointer or -1 if
     *         {@code instructionPointer} denotes an instruction that does not correlate to any bytecode.  This will be
     *         the case when {@code instructionPointer} is not in this target method or is in the adapter frame stub
     *         code, prologue or epilogue.
     */
    public int bciFor(Pointer ip) {
        assert bciToPos != null;
        assert bciToPos.length > 0;
        final int pos = posFor(ip);
        return bciForPos(pos);
    }


    /**
     * Gets the BCI for a target code position in this target method.
     *
     * @param pos a target code position that may denote an instruction in this method correlated with a bytecode
     * @return the start position of the bytecode instruction that is implemented at {@code pos} or -1 if
     *         {@code pos} is outside the range(s) of target code positions in this target method that
     *         correlate with a bytecode.
     */
    public int bciForPos(int pos) {
        assert bciToPos != null;
        assert bciToPos.length > 0;
        int bci;
        if (pos >= posForBci(0)) {
            bci = -1;
            // Search the map backwards as there may be bytecodes for which
            // no target code was emitted. The search is for the first bytecode
            // position that maps to a non-zero target code position less than or
            // equal to 'pos'
            for (int i = bciToPos.length - 1; i >= 0; --i) {
                int p = posForBci(i);
                if (p != 0) {
                    if (p <= pos) {
                        // This is the first bytecode that maps to a non-zero target
                        // code position less than or equal to 'pos'
                        bci = i;
                        break;
                    }
                }
            }
            assert bci >= 0;
            return bci;
        }
        // The instruction pointer denotes a position in the adapter frame code or the prologue
        return -1;
    }

    /**
     * Ensures that the {@linkplain #referenceMaps() reference maps} for this method are finalized. Only
     * finalized reference maps are guaranteed to never change for the remaining lifetime of this target method.
     * <p/>
     * Although this method may be called by multiple threads, it cannot use standard synchronization as that may block
     * one of the threads in native code on a mutex. This would incorrectly be interpreted by the GC as meaning
     * the mutator thread has blocked for GC after taking a safepoint trap. To avoid blocking in native code,
     * a spin loop is used instead.
     * <p/>
     * If this method is called while preparing the stack reference map for a thread that has taken a safepoint
     * for GC, then safepoints are currently disabled and so there is no need to use the {@link NO_SAFEPOINTS}
     * annotation on this method.
     */
    public void finalizeReferenceMaps() {
        final T1XReferenceMapEditor referenceMapEditor = (T1XReferenceMapEditor) this.refMapEditor.get();
        if (referenceMapEditor != null) {
            final Object result = this.refMapEditor.compareAndSwap(referenceMapEditor, T1XReferenceMapEditor.SENTINEL);
            if (result == T1XReferenceMapEditor.SENTINEL) {
                while (this.refMapEditor.get() != null) {
                    Intrinsics.pause();
                }
            } else if (result != null) {
                referenceMapEditor.fillInMaps();
                this.refMapEditor.set(null);
            }
        }
    }

    @Override
    public boolean preserveRegistersForLocalExceptionHandler() {
        return false;
    }

    @Override
    public Address throwAddressToCatchAddress(boolean isTopFrame, Address ip, Class<? extends Throwable> throwableClass) {
        if (handlers.length != 0) {
            if (T1XCompilation.isAMD64() && !isTopFrame) {
                // This puts the ip within a catch range encompassing the call instruction
                ip = ip.minus(1);
            }
            final int excPos = posFor(ip.asPointer());
            int excBCI = bciForPos(excPos);
            if (excBCI != -1) {
                for (CiExceptionHandler e : handlers) {
                    if (e.catchTypeCPI != SYNC_METHOD_CATCH_TYPE_CPI) {
                        if (e.startBCI <= excBCI && excBCI < e.endBCI) {
                            ClassActor catchType = (ClassActor) e.catchType;
                            if (catchType == null || catchType.isAssignableFrom(ClassActor.fromJava(throwableClass))) {
                                int handlerPos = posForBci(e.handlerBCI());
                                checkHandler(excPos, excBCI, e.handlerBCI, handlerPos);
                                return codeStart.plus(handlerPos);
                            }
                        }
                    }
                }
            }
            if (handlers[handlers.length - 1].catchTypeCPI == SYNC_METHOD_CATCH_TYPE_CPI) {
                CiExceptionHandler syncMethodHandler = handlers[handlers.length - 1];
                if (syncMethodHandler.startBCI <= excPos && excPos < syncMethodHandler.endBCI) {
                    int handlerPos = syncMethodHandler.handlerBCI;
                    checkHandler(excPos, excBCI, -1, handlerPos);
                    return codeStart.plus(handlerPos);
                }
            }
        }
        return Address.zero();
    }

    void checkHandler(int excPos, int excBCI, int handlerBCI, int handlerPos) {
        if (handlerPos <= 0 || handlerPos >= code.length) {
            FatalError.unexpected("Bad handler for exception at pos " + excPos + " (bci: " + excBCI + ") in " + this + ": handler pos " + handlerPos + " (bci: " + handlerBCI + ")");
        }
    }

    @Override
    public void traceExceptionHandlers(IndentWriter writer) {
        if (handlers.length != 0) {
            writer.println("Exception handlers:");
            writer.indent();
            for (CiExceptionHandler e : handlers) {
                if (e.catchTypeCPI != SYNC_METHOD_CATCH_TYPE_CPI) {
                    writer.println((e.catchType == null ? "<any>" : e.catchType()) + " @ [" +
                                posForBci(e.startBCI()) + " .. " +
                                posForBci(e.endBCI()) + ") -> " +
                                posForBci(e.handlerBCI()));
                } else {
                    writer.println("<any> @ [" +
                                    e.startBCI() + " .. " +
                                    e.endBCI() + ") -> " +
                                    e.handlerBCI());
                }
            }
            writer.outdent();
        }
    }

    private int bciForCallSite(Pointer returnIP) {
        // The instruction pointer is now just beyond the call machine instruction.
        // In case the call happens to be the last machine instruction for the invoke bytecode we are interested in, we subtract one byte.
        // Thus we always look up what bytecode we were in during the call.
        return bciFor(returnIP.minus(1));
    }

    private static int getInvokeCPI(byte[] code, int invokeBCI) {
        return ((code[invokeBCI + 1] & 0xff) << 8) | (code[invokeBCI + 2] & 0xff);
    }

    /**
     * Prepares the reference map to cover the reference parameters on the stack at a call from a T1X compiled method
     * into a trampoline. These slots are normally ignored when computing the reference maps for a T1X method as they
     * are covered by a reference map in the callee if necessary. They <b>cannot</b> be covered by a reference map in
     * the T1X method as these slots are seen as local variables in a T1X callee and as such can be overwritten with
     * non-reference values.
     *
     * However, in the case where a T1X method calls into a trampoline, the reference parameters of the call are not
     * covered by any reference map. In this situation, we need to analyze the invokeXXX bytecode at the call site to
     * derive the signature of the call which in turn allows us to mark the parameter stack slots that contain
     * references.
     *
     * @param caller the T1X method frame cursor
     */
    private void prepareTrampolineRefMap(Cursor caller, StackReferenceMapPreparer preparer) {
        // prepare the reference map for the parameters passed by the current (caller) frame.
        // the call was unresolved and hit a trampoline, so compute the refmap from the signature of
        // the called method by looking at the bytecode of the caller method
        int bci = bciForCallSite(caller.ip());
        ConstantPool constantPool = codeAttribute.cp;
        byte[] code = codeAttribute.code();
        MethodRefConstant methodRef = constantPool.methodAt(getInvokeCPI(code, bci));
        boolean isInvokestatic = (code[bci] & 0xFF) == Bytecodes.INVOKESTATIC;
        SignatureDescriptor sig = methodRef.signature(constantPool);

        int slotSize = JVMSFrameLayout.JVMS_SLOT_SIZE;
        int numberOfSlots = sig.computeNumberOfSlots() + (isInvokestatic ? 0 : 1);

        if (numberOfSlots != 0) {
            // Handle the parameters in reverse order as caller.sp() is currently
            // pointing at the last parameter.
            Pointer slotPointer = caller.sp();
            for (int i = sig.numberOfParameters() - 1; i >= 0; --i) {
                TypeDescriptor parameter = sig.parameterDescriptorAt(i);
                Kind parameterKind = parameter.toKind();
                if (parameterKind.isReference) {
                    if (traceStackRootScanning()) {
                        Log.print("    parameter ");
                        Log.print(i);
                        Log.print(", type: ");
                        Log.println(parameter.string);
                    }
                    preparer.setReferenceMapBits(caller, slotPointer, 1, 1);
                }
                int parameterSlots = (!parameterKind.isCategory1) ? 2 : 1;
                slotPointer = slotPointer.plus(slotSize * parameterSlots);
            }

            // Finally deal with the receiver (if any)
            if (!isInvokestatic) {
                // Mark the slot for the receiver as it is not covered by the method signature:
                if (traceStackRootScanning()) {
                    Log.print("    receiver, type: ");
                    Log.println(methodRef.holder(constantPool).string);
                }
                preparer.setReferenceMapBits(caller, slotPointer, 1, 1);
            }
        }
    }

    /**
     * @return the number of bytes in {@link #refMaps} corresponding to one stop position.
     */
    int refMapSize() {
        return regRefMapSize() + frameRefMapSize;
    }

    @Override
    public void prepareReferenceMap(Cursor current, Cursor callee, StackReferenceMapPreparer preparer) {
        finalizeReferenceMaps();

        CiCalleeSaveLayout csl = callee.csl();
        Pointer csa = callee.csa();
        TargetMethod calleeTM = callee.targetMethod();
        if (calleeTM != null) {
            Stub.Type st = calleeTM.stubType();
            if (st == InterfaceTrampoline || st == VirtualTrampoline || st == InterfaceTrampoline) {
                prepareTrampolineRefMap(current, preparer);
            } else if (calleeTM.is(TrapStub) && Trap.Number.isStackOverflow(csa)) {
                // a method can never catch stack overflow for itself so there
                // is no need to scan the references in the trapped method
                return;
            }
        }

        int stopIndex = findClosestStopIndex(current.ip());
        int refMapSize = refMapSize();

        if (!csa.isZero()) {
            assert csl != null;
            // the callee contains register state from this frame;
            // use register reference maps in this method to fill in the map for the callee
            Pointer slotPointer = csa;
            int byteIndex = (stopIndex * refMapSize) + frameRefMapSize;
            preparer.tracePrepareReferenceMap(this, stopIndex, slotPointer, "C1X registers frame");
            // Need to translate from register numbers (as stored in the reg ref maps) to frame slots.
            for (int i = 0; i < regRefMapSize(); i++) {
                int b = refMaps[byteIndex] & 0xff;
                int reg = i * 8;
                while (b != 0) {
                    if ((b & 1) != 0) {
                        int offset = csl.offsetOf(reg);
                        if (traceStackRootScanning()) {
                            Log.print("    register: ");
                            Log.println(csl.registers[reg].name);
                        }
                        preparer.setReferenceMapBits(callee, slotPointer.plus(offset), 1, 1);
                    }
                    reg++;
                    b = b >>> 1;
                }
                byteIndex++;
            }
        }

        // prepare the map for this stack frame
        Pointer slotPointer = current.fp().plus(frameRefMapOffset);
        preparer.tracePrepareReferenceMap(this, stopIndex, slotPointer, "T1X frame");
        int byteIndex = stopIndex * refMapSize;
        for (int i = 0; i < frameRefMapSize; i++) {
            preparer.setReferenceMapBits(current, slotPointer, refMaps[byteIndex] & 0xff, 8);
            slotPointer = slotPointer.plusWords(8);
            byteIndex++;
        }
    }

    private Pointer adjustSPForHandler(Pointer sp, Pointer fp) {
        if (isAMD64()) {
            Pointer localVariablesBase = fp;
            // The Java operand stack of the T1X method that handles the exception is cleared
            // when unwinding. The T1X generated handler is responsible for loading the
            // exception from VmThreadLocal.EXCEPTION_OBJECT to the operand stack.
            //
            // Compute the offset to the first stack slot of the Java Stack:
            //
            //    frame size - (space for locals + saved RBP + space of the first slot itself).
            //
            Pointer catcherSP = localVariablesBase.minus(sizeOfNonParameterLocals());

            // The ref maps for the handler address will expect a valid reference to
            // to in stack slot 0 so we store a null there.
            Pointer slot0 = catcherSP.minus(JVMS_SLOT_SIZE);
            for (int i = 0; i < STACK_SLOTS_PER_JVMS_SLOT; i++) {
                slot0.writeReference(i, Reference.zero());
            }

            return catcherSP;
        } else {
            throw unimplISA();
        }
    }

    @Override
    public void adjustFrameForHandler(FrameInfo frame) {
        if (isAMD64()) {
            frame.sp = adjustSPForHandler(frame.sp, frame.fp);
        } else {
            throw unimplISA();
        }
    }

    @Override
    public void catchException(Cursor current, Cursor callee, Throwable throwable) {
        StackFrameWalker sfw = current.stackFrameWalker();
        Address throwAddress = current.ip();
        Address catchAddress = throwAddressToCatchAddress(current.isTopFrame(), throwAddress, throwable.getClass());

        if (!catchAddress.isZero()) {
            if (StackFrameWalker.TraceStackWalk) {
                Log.print("StackFrameWalk: Handler position for exception at position ");
                Log.print(throwAddress.minus(codeStart()).toInt());
                Log.print(" is ");
                Log.println(catchAddress.minus(codeStart()).toInt());
            }

            if (isAMD64()) {
                Pointer localVariablesBase = current.fp();
                Pointer catcherSP = adjustSPForHandler(current.sp(), current.fp());

                // Done with the stack walker
                sfw.reset();

                // Store the exception for the handler
                VmThread.current().storeExceptionForHandler(throwable, this, posFor(catchAddress));

                Stubs.unwind(catchAddress, catcherSP, localVariablesBase);
                FatalError.unexpected("should not reach here");
            } else {
                unimplISA();
            }
        }
    }

    @PLATFORM(cpu = "amd64")
    @HOSTED_ONLY
    private FramePointerStateAMD64 computeFramePointerState(Cursor current, StackFrameWalker stackFrameWalker, Pointer lastPrologueInstr) {
        // Checkstyle: stop
        final byte ENTER = (byte) 0xC8;
        final byte LEAVE = (byte) 0xC9;
        final byte POP_RBP = (byte) 0x5D;

        final byte RET = (byte) 0xC3;
        final byte RET2 = (byte) 0xC2;
        // Checkstyle: resume


        Pointer ip = current.ip();
        byte byteAtIP = stackFrameWalker.readByte(ip, 0);
        if (ip.lessThan(lastPrologueInstr) || byteAtIP == ENTER || byteAtIP == RET || byteAtIP == RET2) {
            return FramePointerStateAMD64.CALLER_FRAME_IN_RBP;
        }
        if (ip.equals(lastPrologueInstr) || byteAtIP == LEAVE) {
            return FramePointerStateAMD64.CALLER_FRAME_AT_RBP;
        }
        if (byteAtIP == POP_RBP) {
            return FramePointerStateAMD64.RETURNING_FROM_RUNTIME;
        }
        return FramePointerStateAMD64.IN_RBP;
    }

    @Override
    public boolean acceptStackFrameVisitor(Cursor current, StackFrameVisitor visitor) {
        if (isAMD64()) {
            StackFrameWalker sfw = current.stackFrameWalker();
            Pointer localVariablesBase = current.fp();
            if (MaxineVM.isHosted()) {
                // Inspector context only
                Pointer startOfPrologue;
                AdapterGenerator generator = AdapterGenerator.forCallee(this);
                if (generator != null) {
                    startOfPrologue = codeStart.plus(generator.prologueSizeForCallee(classMethodActor));
                } else {
                    startOfPrologue = codeStart;
                }
                Pointer lastPrologueInstruction = startOfPrologue.plus(FramePointerStateAMD64.OFFSET_TO_LAST_PROLOGUE_INSTRUCTION);
                FramePointerStateAMD64 framePointerState = computeFramePointerState(current, sfw, lastPrologueInstruction);
                localVariablesBase = framePointerState.localVariablesBase(current);
            }
            StackFrame stackFrame = new AMD64JVMSFrame(sfw.calleeStackFrame(), frame, current.targetMethod(), current.ip(), current.sp(), localVariablesBase, localVariablesBase);
            return visitor.visitFrame(stackFrame);
        } else {
            throw unimplISA();
        }
    }

    @Override
    public void advance(Cursor current) {
        if (isAMD64()) {
            StackFrameWalker sfw = current.stackFrameWalker();
            int dispToRip = frameSize() - sizeOfNonParameterLocals();
            Pointer returnRIP = current.fp().plus(dispToRip);
            Pointer callerFP = sfw.readWord(returnRIP, -Word.size()).asPointer();
            if (MaxineVM.isHosted()) {
                // Inspector context only
                Pointer startOfPrologue;
                AdapterGenerator generator = AdapterGenerator.forCallee(this);
                if (generator != null) {
                    if (generator.advanceIfInPrologue(current)) {
                        return;
                    }
                    startOfPrologue = codeStart.plus(generator.prologueSizeForCallee(classMethodActor));
                } else {
                    startOfPrologue = codeStart;
                }

                Pointer lastPrologueInstruction = startOfPrologue.plus(FramePointerStateAMD64.OFFSET_TO_LAST_PROLOGUE_INSTRUCTION);
                FramePointerStateAMD64 framePointerState = computeFramePointerState(current, sfw, lastPrologueInstruction);
                returnRIP = framePointerState.returnIP(current);
                callerFP = framePointerState.callerFP(current);

            }
            Pointer callerIP = sfw.readWord(returnRIP, 0).asPointer();
            Pointer callerSP = returnRIP.plus(Word.size()); // Skip the rip

            int stackAmountInBytes = classMethodActor.numberOfParameterSlots() * JVMSFrameLayout.JVMS_SLOT_SIZE;
            if (stackAmountInBytes != 0) {
                callerSP = callerSP.plus(stackAmountInBytes);
            }

            // Rescue a return address that has been patched for deoptimization
            callerIP = AMD64TargetMethodUtil.rescuePatchedReturnAddress(sfw, callerIP, callerSP);

            sfw.advance(callerIP, callerSP, callerFP, true);
        } else {
            unimplISA();
        }
    }

    @Override
    public Pointer returnAddressPointer(Cursor frame) {
        if (isAMD64()) {
            int dispToRip = frameSize() - sizeOfNonParameterLocals();
            return frame.fp().plus(dispToRip);
        } else {
            throw unimplISA();
        }
    }

    @Override
    public boolean isDeoptimizationTarget() {
        return true;
    }

    @Override
    public Continuation createDeoptimizedFrame(Info info, CiFrame frame, Continuation cont) {
        int pos;
        Pointer ip;
        int bci = frame.bci;
        ClassMethodActor method = classMethodActor;
        assert method == frame.method : method + " != " + frame.method;
        RiMethod callee = method.codeAttribute().calleeAt(bci);
        CiKind returnKind = callee == null ? null : callee.signature().returnKind();
        if (returnKind != null) {
            // Find instruction *following* the call by searching backwards from the code
            // position of the bytecode instruction after the invoke
            final int invokeSize = 3;
            int succBCI = bci + invokeSize;
            int succPos = bciToPos[succBCI];
            Pointer succIP = codeStart().plus(succPos);
            int index = findClosestStopIndex(succIP.minus(1));
            assert index != -1 : "can't find stop position before " + this + "+" + succPos;

            if (isAMD64()) {
                int call = stopPosition(index);
                int callSize = AMD64TargetMethodUtil.callInstructionSize(code, call);
                assert callSize > 0 : "no call instruction at pos " + call;
                ip = codeStart().plus(call + callSize);
            } else {
                throw unimplISA();
            }
        } else {
            // Must be a safepoint
            pos = bciToPos[bci];
            ip = codeStart().plus(pos);
        }

        // record continuation instruction pointer
        cont.setIP(info, ip);

        // record continuation stack pointer
        cont.setSP(info, CiConstant.forJsr(info.slotsCount()));

        // add operand stack slots
        for (int i = frame.numStack - 1; i >= 0; i--) {
            info.addSlot((CiConstant) frame.getStackValue(i), "ostack");
            for (int pad = 0; pad < STACK_SLOTS_PER_JVMS_SLOT - 1; pad++) {
                info.addSlot(CiConstant.ZERO, "ostack (pad)");
            }
        }

        int paramLocals = method.numberOfParameterSlots();
        int numLocals = frame.numLocals;
        int synchronizedReceiver = -1;
        if (method.isSynchronized() && !method.isStatic()) {
            assert frame.numLocks > 0;
            synchronizedReceiver = numLocals;
            numLocals++;
        }
        int nonParamLocals = numLocals - paramLocals;

        // add (non-parameter) local slots
        for (int i = numLocals - 1; i >= paramLocals; i--) {
            if (i == synchronizedReceiver) {
                info.addSlot((CiConstant) frame.getLockValue(0), "locked rcvr");
            } else {
                info.addSlot((CiConstant) frame.getLocalValue(i), "local");
            }
            for (int pad = 0; pad < STACK_SLOTS_PER_JVMS_SLOT - 1; pad++) {
                info.addSlot(CiConstant.ZERO, "local (pad)");
            }
        }

        // record continuation frame pointer
        cont.setFP(info, CiConstant.forJsr(info.slotsCount()));

        // add template slots
        for (int i = 0; i < templateSlots; i++) {
            info.addSlot(CiConstant.ZERO, "template");
        }

        // add alignment slots
        int numberOfSlots = 1 + templateSlots; // one extra word for the caller FP
        int unalignedSize = (numberOfSlots + (nonParamLocals * STACK_SLOTS_PER_JVMS_SLOT)) * STACK_SLOT_SIZE;
        int alignedSize = target().alignFrameSize(unalignedSize);
        int alignmentSlots = (alignedSize - unalignedSize) / STACK_SLOT_SIZE;
        for (int i = 0; i < alignmentSlots; i++) {
            info.addSlot(CiConstant.ZERO, "align");
        }

        // add caller FP slot with placeholder value
        int callerFPIndex = info.slotsCount();
        info.addSlot(CiConstant.ZERO, "callerFP");

        // add caller return address slot with placeholder value
        int returnAddressIndex = info.slotsCount();
        info.addSlot(CiConstant.ZERO, "returnIP");

        // add parameter slots
        for (int i = paramLocals - 1; i >= 0; i--) {
            info.addSlot((CiConstant) frame.getLocalValue(i), "param");
            for (int pad = 0; pad < JVMSFrameLayout.STACK_SLOTS_PER_JVMS_SLOT - 1; pad++) {
                info.addSlot(CiConstant.ZERO, "param (pad)");
            }
        }

        return new CallerContinuation(callerFPIndex, -1, returnAddressIndex, returnKind);
    }
}

/**
 * Various execution states in a T1X method that can only be observed in
 * the context of the Inspector.
 */
@HOSTED_ONLY
@PLATFORM(cpu = "amd64")
enum FramePointerStateAMD64 {
    /**
     * RBP holds the frame pointer of the current method activation. caller's RIP is at [RBP + FrameSize], caller's
     * frame pointer is at [RBP + FrameSize -1]
     */
    IN_RBP {

        @Override
        Pointer localVariablesBase(Cursor current) {
            return current.fp();
        }

        @Override
        Pointer returnIP(Cursor current) {
            T1XTargetMethod targetMethod = (T1XTargetMethod) current.targetMethod();
            int dispToRip = targetMethod.frameSize() - targetMethod.sizeOfNonParameterLocals();
            return current.fp().plus(dispToRip);
        }

        @Override
        Pointer callerFP(Cursor current) {
            return current.stackFrameWalker().readWord(returnIP(current), -Word.size()).asPointer();
        }
    },

    /**
     * RBP holds the frame pointer of the caller, caller's RIP is at [RSP] This state occurs when entering the
     * method or exiting it.
     */
    CALLER_FRAME_IN_RBP {

        @Override
        Pointer localVariablesBase(Cursor current) {
            int offsetToSaveArea = current.targetMethod().frameSize();
            return current.sp().minus(offsetToSaveArea);
        }

        @Override
        Pointer returnIP(Cursor current) {
            return current.sp();
        }

        @Override
        Pointer callerFP(Cursor current) {
            return current.fp();
        }
    },

    /**
     * RBP points at the bottom of the "saving area". Caller's frame pointer is at [RBP], caller's RIP is at [RBP +
     * WordSize].
     */
    CALLER_FRAME_AT_RBP {

        @Override
        Pointer localVariablesBase(Cursor current) {
            T1XTargetMethod targetMethod = (T1XTargetMethod) current.targetMethod();
            int dispToFrameStart = targetMethod.frameSize() - (targetMethod.sizeOfNonParameterLocals() + Word.size());
            return current.fp().minus(dispToFrameStart);
        }

        @Override
        Pointer returnIP(Cursor current) {
            return current.fp().plus(Word.size());
        }

        @Override
        Pointer callerFP(Cursor current) {
            return current.stackFrameWalker().readWord(current.fp(), 0).asPointer();
        }
    },

    /**
     * Returning from a runtime call (or actually in a runtime call). RBP may have been clobbered by the runtime.
     * The frame pointer for the current activation record is 'RSP + stack slot size'.
     */
    RETURNING_FROM_RUNTIME {

        @Override
        Pointer localVariablesBase(Cursor current) {
            return current.stackFrameWalker().readWord(current.sp(), 0).asPointer();
        }

        @Override
        Pointer returnIP(Cursor current) {
            T1XTargetMethod targetMethod = (T1XTargetMethod) current.targetMethod();
            int dispToRip = targetMethod.frameSize() - targetMethod.sizeOfNonParameterLocals();
            return localVariablesBase(current).plus(dispToRip);
        }

        @Override
        Pointer callerFP(Cursor current) {
            return current.stackFrameWalker().readWord(returnIP(current), -Word.size()).asPointer();
        }
    };

    abstract Pointer localVariablesBase(Cursor current);

    abstract Pointer returnIP(Cursor current);

    abstract Pointer callerFP(Cursor current);

    /**
     * Offset to the last instruction of the prologue from the JIT entry point. The prologue comprises two instructions,
     * the first one of which is enter (fixed size, 4 bytes long).
     */
    public static final int OFFSET_TO_LAST_PROLOGUE_INSTRUCTION = 4;
}
