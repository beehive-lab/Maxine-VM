 Exploring the contract between Maxine and C1X
--------------------------------------------

=====================================================================================
A. Folding and inlining methods by annotation.
=====================================================================================

    Method annotations drive optimization in the CPS compiler. While eventually
the @INLINE, @FOLD, and @CONSTANT annotations will become less necessary due
to C1X's better optimization, C1X has been extended to support some of these
annotations.
    @INLINE, @NEVER_INLINE annotations are handled by C1X through the RiRuntime
interface with .mustInline() and .mustNotInline() methods that are consulted
when C1X makes inlining decisions during compilation.
    @FOLD methods are handled by C1X by providing a mechanism that allows the
VM to register methods as "foldable". Whenever a call to a "foldable" method
is detected, it will be evaluated (via standard Java reflection) if the inputs
are constants.
    @CONSTANT is not currently handled correctly, but it does not require any
changes to C1X. The Maxine implementation of the compiler interface simply
has to return "true" to the .isConstant() call on the RiField for such
fields, and return the appropriate constant value for .constantValue() calls.

=====================================================================================
B. Bytecode extensions for "magic".
=====================================================================================

    Bytecode extensions may make the contract between the compiler and the VM
more explicitly by exposing the "magic" operations and types. While Maxine's
CPS compiler uses the concept of "Builtins" and the special "Word" type, these
are not well contained and have spread throughout the system.

    Bytecode extensions to C1X for Maxine would support the hierarchy of word
types and their operations. Any calls to appropriately annotated methods
would be re-written in a pre-pass over the bytecodes before passing
them to C1X. This pass could be done in the bytecode verifier or
separately. Such a pass would need to identify calls to these special
methods and replace them with the appropriate bytecodes. Additionally,
the bytecodes would be sized appropriately so that they are always
small enough to fit into the space of the bytecodes they replace.
Other non-word magic, such as "UnsafeLoophole", would be rewritten
as well (e.g. UnsafeLoophole.cast() would become nops).

1. A single new BasicType: Word

2. A set of (10) load/store bytecodes:

#1  wload
#2  wload_0
#3  wload_1
#4  wload_2
#5  wload_3
#6  wstore
#7  wstore_0
#8  wstore_1
#9  wstore_2
#10 wstore_3

3. A set of (9) arithmetic operators on words (all unsigned):

#11 wadd
#12 wsub
#13 wdiv
#14 wmul
#15 wand
#16 wor
#17 wxor
#18 wshl
#19 wshr

4. A set of (3) pointer operations:

#20 pread     (read from pointer, type of operand is in constant pool)
#21 pwrite    (write to pointer, type of operand is in constant pool)
#22 pcmpswp   (compare and swap, type of operand is in constant pool)

5. A set of (10) comparison operators:

#23 swcmp     (Signed word compare)
#24 swlt
#25 swgt
#26 swlteq
#27 swgteq
#28 uwcmp     (Unsigned word compare)
#29 uwlt
#30 uwgt
#31 uwlteq
#32 uwgteq

6. A set of (6) conversion operators:

#33 w2i   (word to integer)
#34 w2l   (word to long)
#35 i2w   (integer to word)
#36 l2w   (long to word)
#37 w2a   (word to object)
#38 a2w   (object to word)

7. An optional set of operators for performance

#39 wroundup4    (align word on next 4 byte boundary)
#40 wroundup8
#41 wroundup16
#42 wroundupdn4    (align word on previous 4 byte boundary)
#43 wroundupdn8
#44 wroundupdn16
#45 wudiv        (unsigned divide)
#46 pfread       (prefetch for read)
#47 pfwrite      (prefetch for write)

8. An invokenative instruction (?)

#48 invokenative  (invoke a native method using the native abi)


Note that the rewriting of the bytecodes would of course confuse tools
that process Java bytecodes. Because of this, the rewritten bytecodes
would only be kept internally in Maxine, and not written out to class
files. To view rewritten bytecodes in the Inspector, for example,
would require modifications to the Inspector.

    C1X would provide an interface for bytecode extensions to be installed
by the VM. When C1X processes bytecode, any undefined bytecodes encountered
would trigger appropriate calls to the bytecode extensions installed.

Information needed by C1X for extended bytecodes:

Globally:
    - name of bytecode
    - operator of bytecode (string representation for instruction printing)


BlockMap:
    - length of the bytecode
    - can the bytecode trap?
        (can assume "yes" conservatively for new bytecodes)
    - which locals, if any, does the bytecode store to?
        (used to compute stores in loops for phi's in graph builder)
    * does the bytecode end a block?
        (can assume "no" and disallow control flow extensions)

ArithmeticOp:
    - is bytecode operation commutative?
        (can assume "no" conservatively)

GraphBuilder:
    - IR node(s) to be generated
    - effect on stack state (ValueStack)

Optimizations:
    - can the operation be folded for constant inputs?
        (can assume "no" conservatively)
    - fold (evaluate) operations on constant inputs
    - value number and value equal for IR nodes

Lowering:
    - translation to lower-level operations (LIR / XIR)

=====================================================================================
C. Stack frame walking / reference map issues
=====================================================================================

=====================================================================================
D. JNI issues
=====================================================================================

=====================================================================================
E. Native method invocations
=====================================================================================
